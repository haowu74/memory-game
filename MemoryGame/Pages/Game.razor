@page "/"
@page "/index"
@using MemoryGame.Models

<PageTitle>Memory Game</PageTitle>

<h1>Memory Game</h1>

<h3>Level:<span id="level">@gm.Level</span></h3>



<div class="board">
    @for (var i = 0; i < gm.BoardSize; i++)
    {
        @for (var j = 0; j < gm.BoardSize; j++)
        {
            int x = i;
            int y = j;
            <div class="flip-card">
                <div class="flip-card-inner" style=@(gm.Cards.ElementAt(i * gm.BoardSize + j).Revealed || gm.Cards.ElementAt(i * gm.BoardSize + j).Matched ? "transform: rotateY(180deg)" : "transform: rotateY(0deg)")>
                    <div class="card-front" id="card-front-@(x)-@(y)">@gm.Cards.ElementAt(i * gm.BoardSize + j).Text</div>
                    <div class="card-back" id="card-back-@(x)-@(y)" @onclick="@(() => CardBackClicked(x, y))"></div>
                </div>
            </div>
        }
    }
</div>

@code {

    GameModel gm = new GameModel();

    bool LimitReached = false;
    System.Timers.Timer t;

    public void CardBackClicked(int row, int col)
    {
        if (LimitReached)
        {
            return;
        }
        gm.Cards.ElementAt(row * gm.BoardSize + col).Revealed = true;
        LimitReached = gm.Match();
        if (LimitReached)
        {
            t = new System.Timers.Timer(1000);
            t.Elapsed += new System.Timers.ElapsedEventHandler(f);
            t.Start();
        }
        StateHasChanged();
    }

    void f(object sender, System.Timers.ElapsedEventArgs e)
    {
        foreach(var card in gm.Cards)
        {
            card.Revealed = false;
        }
        LimitReached = false;
        StateHasChanged();
        t.Stop();    
    }
}
