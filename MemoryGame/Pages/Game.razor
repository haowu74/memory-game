@page "/"
@page "/index"
@using MemoryGame.Models

<PageTitle>Memory Game</PageTitle>

<h1>Memory Game</h1>

<h3>Level:</h3>
<select @bind="@Level">
    <option value="1">1</option>
    <option value="2">2</option>
    <option value="3">3</option>
    <option value="4">4</option>
</select>



<div class="board">
    @for (var i = 0; i < gm.BoardSize; i++)
    {
        @for (var j = 0; j < gm.BoardSize; j++)
        {
            int x = i;
            int y = j;
            <div class="flip-card">
                <div class="flip-card-inner" style=@(gm.Cards.ElementAt(i * gm.BoardSize + j).Revealed || gm.Cards.ElementAt(i * gm.BoardSize + j).Matched ? "transform: rotateY(180deg)" : "transform: rotateY(0deg)")>
                    <div class="card-front" id="card-front-@(x)-@(y)">@gm.Cards.ElementAt(i * gm.BoardSize + j).Text</div>
                    <div class="card-back" id="card-back-@(x)-@(y)" @onclick="@(() => CardBackClicked(x, y))"></div>
                </div>
            </div>
        }
    }
</div>

@code {

    GameModel gm = new GameModel();

    bool LimitReached = false;
    System.Timers.Timer t = new System.Timers.Timer(1000);

    [Parameter]
    public int Level 
    {
        get
        {
            return gm.Level;
        }
        set
        {
            gm.Level = value;
        } 
    }

    public void CardBackClicked(int row, int col)
    {
        if (LimitReached)
        {
            return;
        }
        gm.Cards.ElementAt(row * gm.BoardSize + col).Revealed = true;
        LimitReached = gm.Match();
        if (LimitReached)
        {
            t.Elapsed += this.f;
            t.Start();
        }
        StateHasChanged();
    }

    void f(object? sender, System.Timers.ElapsedEventArgs e)
    {
        foreach(var card in gm.Cards)
        {
            card.Revealed = false;
        }
        LimitReached = false;
        StateHasChanged();
        t.Stop();
        t.Elapsed -= this.f;
    }
}
